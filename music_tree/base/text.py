from music_tree.base.timecode import Timecode


class Text():
    """ Сопоставление таймкодов и нот/нод. """

    # В составе текста нужно располагать не отдельные ноты-точки, а области,
    # у которых нужно запрашивать, не хотят ли они что-то добавить в данный момент
    # NOTE: Напрашивается некая параллель с рейтрейсингом.

    # @notes - сопоставление таймкод-нода
    # Если в качестве ноды - число - проигрываем просто его
    # Если объект - надо запросить у него ноту для данного конкретного таймкода.
    # Объект должен знать (или ему надо передать в качестве параметра) точку его
    # начала, объект должен вернуть - есть нота в этой точке или нет

    def __init__(self):
        # NOTE: попробуем на основе дикта вместо списка пар таймкод-значение
        self.notes = dict()
        self.last = Timecode(0, 0)

    def add(self, timecode, node):
        # NOTE: подразумеваем возможность размещать в данной точке любую ноду.
        # С учётом того, что в качестве ноды может выступать слово с ударением не на первой ноте,
        # фактическое начало ноды может быть раньше - реализация слов
        self.notes[timecode] = node

    def concretize(self):
        """ Вовзращает словарь из нот - все ноды уже "развёрнуты" """
        return dict()
